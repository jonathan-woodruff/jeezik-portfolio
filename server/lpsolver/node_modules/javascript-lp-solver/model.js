exports.generateOptimalPaths = (selectedDoctors) => {
    /* inputs */
    const doctors = []; //all the doctors that will be available at least one day

    for (let doctor in selectedDoctors) {
        doctors.push(selectedDoctors[doctor].name);
    };

    const n = [4, 8, 9] //number of nodes Monday is 4, Tuesday is 8

    const days = ["Monday", "Tuesday", "Wednesday"];

    const H = []; //doctors available to work at index g (day)

    for (let g = 0; g < days.length; g++) {
        H.push([]);
        for (let doctor in selectedDoctors) {
            H[g].push(selectedDoctors[doctor].name);
        };
    };

    b = []
    for (let g = 0; g < days.length; g++) {
        if (n[g] < H[g].length) {
            b.push(n[g]);
        } else {
            b.push(H[g].length);
        }
    }

    //Index 0 is reserved for the dummy source node
    //The last index is reserved for the dummy destination node
    const c = [ //costs
        [ //c[0] === day 0 monday
            [0, 0, 0, 0, 0, Infinity], //c[0][0][5] = Infinity
            [Infinity, 0, 10, 5, 20, 0],
            [Infinity, Infinity, 0, 4, 10, 0],
            [Infinity, Infinity, Infinity, 0, 13, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity]
        ],
        [ //c[1] === day 1 tuesday
            [0, 0, 0, 0, 0, 0, 0, 0, 0, Infinity],
            [Infinity, 0, 20, 40, 18, 44, 45, 8, 9, 0],
            [Infinity, Infinity, 0, 3, 6, 7, 5, 14, 6, 0],
            [Infinity, Infinity, Infinity, 0, 5, 5, 3, 8, 7, 0],
            [Infinity, Infinity, Infinity, Infinity, 0, 6, 9, 5, 4, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, 0, 6, 17, 16, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 33, 22, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 5, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity]
        ],
        [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Infinity],
            [Infinity, 0, 50, 15, 15, 14, 9, 6, 7, 12, 0],
            [Infinity, Infinity, 0, 35, 34, 90, 80, 65, 50, 75, 0],
            [Infinity, Infinity, Infinity, 0, 15, 70, 60, 45, 20, 60, 0],
            [Infinity, Infinity, Infinity, Infinity, 0, 65, 55, 19, 18, 35, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, 0, 10, 25, 41, 12, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 17, 27, 5, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 16, 16, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 28, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, 0, 0],
            [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity]
        ]
    ];

    /* initialize decision variables */
    const variables = {};
    const ints = {};
    for (let g = 0; g < days.length; g++) {
        for (let h = 0; h < H[g].length; h++) {
            for (let i = 0; i < n[g] + 2; i++) { //i == 0 is dummy source node. i == n[g] + 1 is the dummy destination node
                for (let j = 0; j < n[g] + 2; j++) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key] = {
                        "travel time": c[g][i][j] //for the objective function
                    };
                    ints[key] = 1;
                }
            }
        }
    }

    /*constraints 
    *** c1, c2, c3, and c4 combine to make rules for the network such that on a given day, a given doctor starts from the source dummy, goes to a real node, and then finishes at the dummy destination node
    *** c5 ensures that for a given doctor on a given day, if that doctor goes to a real node, it must then go from that real node to another node. Without c5, a doctor could go from dummy source to real node 1 and then go from real node 2 to the dummy destination without going from node 1 to node 2
    *** c6 ensures that no doctor goes to the dummy destination twice. Since c3 sets the number of edges going to the destination dummy node, c6 therefore ensures that multiple doctors can go to the dummy destination. Without c6, doctor 0 might be the only one traversing the nodes.
    *** c7 ensures that each real node is visited. Without it, you might get the doctors visiting only some of the real nodes.
    */
    const constraints = {};
    let attribute;

    //c1: #total edges = #nodes + b[g]
    for (let g = 0; g < days.length; g++) {
        attribute = "c1 " + g.toString();
        constraints[attribute] = { "equal": n[g] + b[g] };
        for (let h = 0; h < H[g].length; h++) {
            for (let i = 0; i < n[g] + 2; i++) { //i == 0 is the dummy source, i == n[g] + 1 is the dummy destination
                for (let j = 0; j < n[g] + 2; j++) { //all nodes
                    if (j !== i) {
                        key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                        variables[key][attribute] = 1;
                    }
                }
            }
        }
    }

    //c2: The number of edges going from the source dummy node to a real node = b[g]
    for (let g = 0; g < days.length; g++) {
        attribute = "c2 " + g.toString();
        constraints[attribute] = { "equal": b[g] };
        for (let h = 0; h < H[g].length; h++) {
            for (let j = 1; j < n[g] + 1; j++) { //real nodes
                let i = 0;
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1;
            }
        }
    }

    //c3: The number of edges going from real nodes to the destination dummy node = b[g]
    for (let g = 0; g < days.length; g++) {
        attribute = "c3 " + g.toString();
        constraints[attribute] = { "equal": b[g] };
        for (let h = 0; h < H[g].length; h++) {
            for (let i = 1; i < n[g] + 1; i++) { //real nodes
                let j = n[g] + 1; //dummy destination node
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1;
            }
        }
    }

    //c4: The number of edges going from a real node to a real node = n[g] - b[g]
    for (let g = 0; g < days.length; g++) {
        attribute = "c4 " + g.toString();
        constraints[attribute] = { "equal": n[g] - b[g] };
        for (let h = 0; h < H[g].length; h++) {
            for (let i = 1; i < n[g] + 1; i++) { //real nodes
                for (let j = 1; j < n[g] + 1; j++) { //real nodes
                    if (j !== i) {
                        key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                        variables[key][attribute] = 1;
                    }
                }
            }
        }
    }

    //c5: For a given doctor, if a real node is a destination, it must also be a source node for that doctor.
    for (let g = 0; g < days.length; g++) {
        for (let h = 0; h < H[g].length; h++) {
            for (let j = 1; j < n[g] + 1; j++) { //real nodes
                attribute = "c5 " + g.toString() + " " + h.toString() + " " + j.toString();
                constraints[attribute] = { "equal": 0 };
                for (let k = 1; k < n[g] + 2; k++) { //real and destination dummy nodes
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + j.toString() + "][" + k.toString() + "]";
                    variables[key][attribute] = 1;
                }
                for (let i = 0; i < n[g] + 1; i++) { //real and source dummy nodes 
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = -1;
                }
            }
        }
    }

    //c6: Each doctor can go to the dummy destination node at most one time
    for (let g = 0; g < days.length; g++) {
        for (let h = 0; h < H[g].length; h++) {
            attribute = "c6 " + g.toString() + " " + h.toString();
            constraints[attribute] = { "max": 1 };
            let j = n[g] + 1;
            for (let i = 1; i < n[g] + 1; i++) { //real nodes
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1;
            }
        }
    }

    //c7: Each real node must be visited
    for (let g = 0; g < days.length; g++) {
        for (let j = 1; j < n[g] + 1; j++) { //real nodes
            attribute = "c7 " + g.toString() + " " + j.toString();
            constraints[attribute] = { "equal": 1 };
            for (let h = 0; h < H[g].length; h++) {
                for (let i = 0; i < n[g] + 1; i++) { //dummy source node and real nodes
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1;
                }
            }
        }
    }

    /* model */
    var solver = require("javascript-lp-solver/src/solver"),
    results,
    model = {
        "optimize": "travel time",
        "opType": "min",
        "constraints": constraints,
        "variables": variables,
        "ints": ints
    };
    
    results = solver.Solve(model);
    return results;
};