//run python: https://stackoverflow.com/questions/23450534/how-to-call-a-python-function-from-node-js

/* inputs */
const nodes = {
    "Monday": {
        "0": { //node 0
            "location": "Department 1",
            "start time": 8,
            "end time": 9
        },
        "1": { //node 1
            "location": "Department 1",
            "start time": 9,
            "end time": 10
        },
        "2": { //node 2
            "location": "Department 2",
            "start time": 8,
            "end time": 10
        }
    },
    "Tuesday": {
        "0": { //node 0
            "location": "Department 1",
            "start time": 8,
            "end time": 9
        },
        "1": { //node 1
            "location": "Department 2",
            "start time": 8,
            "end time": 9
        },
        "2": { //node 2
            "location": "Department 3",
            "start time": 9,
            "end time": 10
        }
    }
}

const H = [ //doctors available to work at index g (day)
    ["doc 1", "doc 2"],
    ["doc 1", "doc 2"],
    ["doc 1", "doc 2"]
];

const n = [3, 3, 3] //number of nodes Monday is 3, Tuesday is 3

const days = ["Monday", "Tuesday", "Wednesday"];

b = []
for (let g = 0; g < days.length; g++) {
    if (n[g] < H[g].length) {
        b.push(n[g]);
    } else {
        b.push(H[g].length);
    }
}

//Index 0 is reserved for the dummy source node
//The last index is reserved for the dummy destination node
const c = [ //costs
    [ //c[0] = day 0 monday
        [0, 0, 0, 0, Infinity], //c[0][0][4] = Infinity
        [Infinity, 0, 0, Infinity, 0],
        [Infinity, Infinity, 0, Infinity, 0],
        [Infinity, Infinity, Infinity, 0, 0],
        [Infinity, Infinity, Infinity, Infinity, Infinity]
    ],
    [ //c[1] = day 1 - tuesday
        [0, 0, 0, 0, Infinity],
        [Infinity, 0, Infinity, 15, 0],
        [Infinity, Infinity, 0, 20, 0],
        [Infinity, Infinity, Infinity, 0, 0],
        [Infinity, Infinity, Infinity, Infinity, Infinity]
    ],
    [
        [0, 0, 0, 0, Infinity],
        [Infinity, 0, 100, 1000, 0],
        [Infinity, 100, 0, 10, 0],
        [Infinity, 1000, 10, 0, 0],
        [Infinity, Infinity, Infinity, Infinity, Infinity]
    ]
];

const m = [ //hours spent at the real node (source)
    [1, 1, 2], //day 0
    [1, 1, 1], //day 1
    [1, 1, 6]
];

/* initialize decision variables */
const variables = {};
const ints = {};
variables["u"] = { "daily max": 1 };
variables["v"] = { "daily max": 1 };
variables["w"] = { "daily max": 1 };
variables["y"] = { "daily max": 1 };
for (let g = 0; g < days.length; g++) {
    for (let h = 0; h < H[g].length; h++) {
        for (let i = 0; i < n[g] + 2; i++) { //i == 0 is dummy source node. i == n[g] + 1 is the dummy destination node
            for (let j = 0; j < n[g] + 2; j++) {
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key] = {
                    "travel time": c[g][i][j] //for the objective function
                };
                ints[key] = 1;
            }
        }
    }
}

/*constraints 
*** c1, c2, c3, and c4 combine to make rules for the network such that on a given day, a given doctor starts from the source dummy, goes to a real node, and then finishes at the dummy destination node
*** c5 ensures that for a given doctor on a given day, if that doctor goes to a real node, it must then go from that real node to another node. Without c5, a doctor could go from dummy source to real node 1 and then go from real node 2 to the dummy destination without going from node 1 to node 2
*** c6 ensures that no doctor goes to the dummy destination twice. Since c3 sets the number of edges going to the destination dummy node, c6 therefore ensures that multiple doctors can go to the dummy destination. Without c6, doctor 0 might be the only one traversing the nodes.
*** c7 ensures that each real node is visited. Without it, you might get the doctors visiting only some of the real nodes.
*/
const constraints = {};
let attribute;

//c1: #total edges = #nodes + b[g]
for (let g = 0; g < days.length; g++) {
    attribute = "c1 " + g.toString();
    constraints[attribute] = { "equal": n[g] + b[g] };
    for (let h = 0; h < H[g].length; h++) {
        for (let i = 0; i < n[g] + 2; i++) { //i == 0 is the dummy source, i == n[g] + 1 is the dummy destination
            for (let j = 0; j < n[g] + 2; j++) { //all nodes
                if (j !== i) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1;
                }
            }
        }
    }
}

//c2: The number of edges going from the source dummy node to a real node = b[g]
for (let g = 0; g < days.length; g++) {
    attribute = "c2 " + g.toString();
    constraints[attribute] = { "equal": b[g] };
    for (let h = 0; h < H[g].length; h++) {
        for (let j = 1; j < n[g] + 1; j++) { //real nodes
            let i = 0;
            key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
            variables[key][attribute] = 1;
        }
    }
}

//c3: The number of edges going from real nodes to the destination dummy node = b[g]
for (let g = 0; g < days.length; g++) {
    attribute = "c3 " + g.toString();
    constraints[attribute] = { "equal": b[g] };
    for (let h = 0; h < H[g].length; h++) {
        for (let i = 1; i < n[g] + 1; i++) { //real nodes
            let j = n[g] + 1; //dummy destination node
            key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
            variables[key][attribute] = 1;
        }
    }
}

//c4: The number of edges going from a real node to a real node = n[g] - b[g]
for (let g = 0; g < days.length; g++) {
    attribute = "c4 " + g.toString();
    constraints[attribute] = { "equal": n[g] - b[g] };
    for (let h = 0; h < H[g].length; h++) {
        for (let i = 1; i < n[g] + 1; i++) { //real nodes
            for (let j = 1; j < n[g] + 1; j++) { //real nodes
                if (j !== i) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1;
                }
            }
        }
    }
}

//c5: For a given doctor, if a real node is a destination, it must also be a source node for that doctor.
for (let g = 0; g < days.length; g++) {
    for (let h = 0; h < H[g].length; h++) {
        for (let j = 1; j < n[g] + 1; j++) { //real nodes
            attribute = "c5 " + g.toString() + " " + h.toString() + " " + j.toString();
            constraints[attribute] = { "equal": 0 };
            for (let k = 1; k < n[g] + 2; k++) { //real and destination dummy nodes
                key = "x[" + g.toString() + "][" + h.toString() + "][" + j.toString() + "][" + k.toString() + "]";
                variables[key][attribute] = 1;
            }
            for (let i = 0; i < n[g] + 1; i++) { //real and source dummy nodes 
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = -1;
            }
        }
    }
}

//c6: Each doctor can go to the dummy destination node at most one time
for (let g = 0; g < days.length; g++) {
    for (let h = 0; h < H[g].length; h++) {
        attribute = "c6 " + g.toString() + " " + h.toString();
        constraints[attribute] = { "max": 1 };
        let j = n[g] + 1;
        for (let i = 1; i < n[g] + 1; i++) { //real nodes
            key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
            variables[key][attribute] = 1;
        }
    }
}

//c7: Each real node must be visited
for (let g = 0; g < days.length; g++) {
    for (let j = 1; j < n[g] + 1; j++) { //real nodes
        attribute = "c7 " + g.toString() + " " + j.toString();
        constraints[attribute] = { "equal": 1 };
        for (let h = 0; h < H[g].length; h++) {
            for (let i = 0; i < n[g] + 1; i++) { //dummy source node and real nodes
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1;
            }
        }
    }
}

//c8: assigns the number of hours of the doctor who works the most hours on a given day
for (let g = 0; g < days.length; g++) {
    for (let h = 0; h < H[g].length; h++) {
        attribute = "c8 " + g.toString() + " " + h.toString();
        constraints[attribute] = { "equal": 0 };
        for (let i = 1; i < n[g] + 1; i++) {
            for (let j = 1; j < n[g] + 1; j++) { //real nodes and dummy destination node
                if (j !== i) {
                    
                }
            }
        }
    }
}

/*
//c1: #real edges = #nodes - #doctors
for (let g = 0; g < days.length; g++) {
    attribute = "c1 " + g.toString();
    constraints[attribute] = { "equal": n[g] - H[g].length };
    for (let h = 0; h < H[g].length; h++) {
        for (let i = 0; i < n[g]; i++) {
            for (let j = 0; j < n[g]; j++) {
                if (j !== i) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1;
                }
            }
        }
    }
}

//c2: every real node must be a source
for (let g = 0; g < days.length; g++) {
    for (let i = 0; i < n[g]; i++) {
        attribute = "c2 " + g.toString() + " " + i.toString();
        constraints[attribute] = { "equal": 1 };
        for (let h = 0; h < H[g].length; h++) {
            for (let j = 0; j < n[g] + 1; j++) {
                if (j !== i) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1;
                }
            }
        }
    }
}

//c3: Each doctor goes to the dummy node
for (let g = 0; g < days.length; g++) {
    for (let h = 0; h < H[g].length; h++) {
        attribute = "c3 " + g.toString() + " " + h.toString();
        constraints[attribute] = { "equal": 1 };
        for (let i = 0; i < n[g]; i++) {
            for (let j = n[g]; j < n[g] + 1; j++) {
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1;
            }
        }
    }
}

//c4: #edges = #nodes
for (let g = 0; g < days.length; g++) {
    attribute = "c4 " + g.toString();
    constraints[attribute] = { "equal": n[g] };
    for (let h = 0; h < H[g].length; h++) {
        for (let i = 0; i < n[g] + 1; i++) {
            for (let j = 0; j < n[g] + 1; j++) {
                if (j !== i) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1;
                }
            }
        }
    }
}
*/

/*
//c1
for (let g = 0; g < days.length; g++) {
    for (let j = 0; j < n[g]; j++) {
        attribute = "c1 " + g.toString() + " " + j.toString();
        constraints[attribute] = { "equal": 1 };
        for (let h = 0; h < doctors.length; h++) {
            for (let i = 0; i < n[g]; i++) {
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1
            }
        }
    }
}

//c2
for (let g = 0; g < days.length; g++) {
    for (let i = 0; i < n[g]; i++) {
        attribute = "c2 " + g.toString() + " " + i.toString();
        constraints[attribute] = { "equal": 1 };
        for (let h = 0; h < doctors.length; h++) {
            for (let j = 0; j < n[g]; j++) {
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1
            }
        }
    }
}

//c3
for (let g = 0; g < days.length; g++) {
    attribute = "c3 " + g.toString();
    constraints[attribute] = { "equal": n[g] };
    for (let h = 0; h < doctors.length; h++) {
        for (let i = 0; i < n[g]; i++) {
            for (let j = 0; j < n[g]; j++) {
                key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                variables[key][attribute] = 1
            }
        }
    }
}

//c6
for (let g = 0; g < days.length; g++) {
    attribute = "c6 " + g.toString();
    constraints[attribute] = { "equal": n[g] - doctors.length };
    for (let h = 0; h < doctors.length; h++) {
        for (let i = 0; i < n[g]; i++) {
            for (let j = 0; j < n[g]; j++) {
                if (i !== j) {
                    key = "x[" + g.toString() + "][" + h.toString() + "][" + i.toString() + "][" + j.toString() + "]";
                    variables[key][attribute] = 1
                }
            }
        }
    }
}
*/
//console.log(constraints);
//console.log(variables);

/* constraint 3 */
/*let key;
for (let i = 0; i < n.length; i++) {
    key = "nodes day " + i.toString();
    constraints[key] = n[i];
};*/

/* constraint 4 */
//constraints["backward in time"] = 0;

/* constraint 5 */
//constraints["length of workday"] = 0;



/* Set up variables */
/*let dayNodes, nestedKey;
for (let k = 0; k < doctors.length; k++) {
    for (let l = 0; l < days.length; l++) {
        dayNodes = nodes[days[l]]
        for (let i = 0; i < n[l]; i++) {
            for (let j = 0; j < n[l]; j++) {
                key = i.toString() + " | " + j.toString() + " | " + k.toString() + " | " + l.toString();
                variables[key] = {
                    "travel time": c[l][i][j],
                    "sources": 1,
                    "destinations": 1,
                    "backward in time": 1,
                    "length of workday": c[l][i][j] + h[l][i]
                }
                for (let m = 0; m < n.length; m ++) {
                    nestedKey = "nodes day " + m.toString();
                    variables[key][nestedKey] = 1;
                }
            }
        }
    }
}*/

/* model */
var solver = require("./src/solver"),
  results,
  model = {
    "optimize": "travel time",
    "opType": "min",
    "constraints": constraints,
    "variables": variables,
    "ints": ints
};
 
results = solver.Solve(model);
console.log(results);